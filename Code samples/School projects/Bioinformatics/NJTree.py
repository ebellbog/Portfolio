#!/usr/bin/python
#CS 68, Bioinformatics: Lab 4
#By Elana Bogdan and Emily Dolson

import pygraphviz as pgv
import sys, os, copy

def main():
    #Make sure command-line arguments are valid
    if len(sys.argv) < 2:
        print "Usage: NJTree.py distances"
        exit()
    if not os.path.exists(sys.argv[1]):
        print "Invalid distances file entered"
        exit()

    #Parse input and run algorithm
    distances = readDistances(sys.argv[1])
    tree = neighborJoining(distances)

    #Output results
    printGraph(tree, "tree.png")
    printTree(tree)

def printTree(tree):
    """
    Prints the distances between all connected nodes in the given tree.
    """
    keys = tree.keys()
    keys.sort() #print in alphabetical order
    for key in keys: #each value dictionary only has one entry, so this works
        print key, tree[key].keys()[0], tree[key].values()[0]

def printGraph(tree, filename):
    """
    Generates a png image of the inputted tree.
    Inputs: tree - a dictionary of dictionaries in which the value of the
    second key is the distance between the first key and the second key.
    filename - the name of the file in which to save the image.
    Returns nothing
    """
    G = pgv.AGraph() #Constructs a graph object
    for key in tree.keys():
        G.add_node(key)
        for subkey in tree[key].keys():
            G.add_node(subkey)
            G.add_edge(key,subkey,label=str(tree[key][subkey]),\
                       len=max(1, tree[key][subkey]))
            #length can't be less than 1, so that labels are readable

    G.draw(filename,prog="neato") 

def neighborJoining(distances):
    """
    Peforms the neigbor joining algorithm on the given distance matrix.
    Inputs: distances - a dictionary of dictionaries in which the value of the
    second key is the distance between the first key and the second key.
    Returns: a dictionary of dictionaries representing the tree generated by
    the algorithm. The keys for the first dictionary are the names of child
    nodes and their values are dictionaries representing their parent. The
    values of parent dictionaries are the distances between the child and
    parent.
    """

    tree = {}

    while(len(distances.keys()) > 2):

        r = calcRs(distances)
        M = makeMMatrix(distances, r)

        smallest = 10000
        smallestKey = ("","")

        #Find nearest neighbors
        for key in M.keys():
            for subkey in M[key].keys():
                if M[key][subkey] < smallest:
                    smallest = M[key][subkey]
                    smallestKey = (key, subkey)

        #Add new node and update distances to rest of tree
        newname = smallestKey[0] + "-" + smallestKey[1]
        distances[newname] = {}
        tree[smallestKey[0]] = {}
        tree[smallestKey[1]] = {}
        dij = distances[smallestKey[0]][smallestKey[1]]
        for key in M.keys():
            if key in smallestKey:
                continue
            distances[newname][key] = .5*(distances[smallestKey[0]][key] \
                     + distances[smallestKey[1]][key] - dij)
            distances[key][newname] = distances[newname][key]

        #Update distances to parents of node
        dik = (dij + r[smallestKey[0]] - r[smallestKey[1]])/2
        tree[smallestKey[0]][newname] = dik
        tree[smallestKey[1]][newname] = dij-dik
        detachDict(distances, smallestKey[0], smallestKey[1])

    #Connect final two nodes
    tree[distances.keys()[0]] = {}
    tree[distances.keys()[0]][distances[distances.keys()[0]].keys()[0]] =\
      distances[distances.keys()[0]][distances[distances.keys()[0]].keys()[0]] 
    return tree

def detachDict(dict, key1, key2):
    """
    Remove key1 and key2 from dict.
    Inputs: dict - a dictionary, key1 and key2 - keys in the dictionary to
    be removed
    Returns: nothing
    """

    for key in dict.keys():
        if key == key1 or key == key2:
            del dict[key]
        else:
            for subkey in dict[key].keys():
                if subkey == key1 or subkey == key2:
                    del dict[key][subkey]

def calcRs(distances):
    """
    Calculates the r values for the neighbor-joining algorithm.
    Input: distances - a dictionary of dictionaries in which the value of the
    second key is the distance between the first key and the second key.
    Returns: a dictionary containing the r values for each of the keys in
    the distances dictionary.
    """
    r = {}
    
    for key in distances.keys():
        summedDistances = 0
        for subkey in distances[key].keys():
            summedDistances += distances[key][subkey]
        r[key] = summedDistances/(len(distances.keys())-2)

    return r

def makeMMatrix(distances, r):
    """
    Calculates M, the matrix of adjusted distances for the neighbor-joining
    algorithm.
    Input: distances - a dictionary of dictionaries in which the value of the
    second key is the distance between the first key and the second key.
    r - a dictionary containing the r values for each of the keys in
    the distances dictionary.
    Returns: the M matrix
    """
    M = copy.deepcopy(distances)

    for key in M.keys():
        for subkey in M[key].keys():
            M[key][subkey] -= (r[key] + r[subkey])

    return M


def readDistances(fileName):
    """
    Reads a file containing distances between groups.
    Expected format for lines in the file is: group1name group2name distance
    Input: filename - the name of the file containing distances
    Returns: a dictionary of dictionaries in which the value of the
    second key is the distance between the first key and the second key.
    """
    infile = open(fileName, "r")
    distances = {}

    for line in infile:
        line = [i.strip() for i in line.split()]
        if not distances.has_key(line[0]):
            distances[line[0]] = {}
        distances[line[0]][line[1]] = float(line[2])

        if not distances.has_key(line[1]):
            distances[line[1]] = {}
        distances[line[1]][line[0]] = float(line[2])

    infile.close()
    return distances
        
            


if __name__ == "__main__":
    main()
